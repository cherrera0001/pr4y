// PR4Y - Prisma schema
// Postgres database

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model User {
  id           String        @id @default(uuid())
  email        String        @unique
  passwordHash String?       @map("password_hash") // null para usuarios OAuth (Google)
  googleId     String?       @unique @map("google_id")
  role         String        @default("user") // "user" | "admin" | "super_admin"
  status       String        @default("active") // "active" | "banned"
  lastLoginAt  DateTime?     @map("last_login_at")
  createdAt    DateTime      @default(now()) @map("created_at")
  refreshTokens RefreshToken[]
  wrappedDek   WrappedDek?
  records      Record[]
  usageLogs    UsageLog[]
  @@map("users")
}

// Contenido global publicado por admin (oraciones, avisos, etc.) que la app muestra a los usuarios.
model GlobalContent {
  id        String   @id @default(uuid())
  type      String   // p. ej. "prayer", "announcement"
  title     String
  body      String   @db.Text
  published Boolean @default(false)
  sortOrder Int      @default(0) @map("sort_order")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  @@index([type, published])
  @@map("global_content")
}

// Metadatos de uso: cuándo y cuánto sincroniza cada usuario (bytes), sin contenido. E2EE respetado.
model UsageLog {
  id          String   @id @default(uuid())
  userId      String   @map("user_id")
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  day         DateTime @db.Date
  bytesPushed BigInt   @default(0) @map("bytes_pushed")
  bytesPulled BigInt   @default(0) @map("bytes_pulled")
  pushCount   Int      @default(0) @map("push_count")
  pullCount   Int      @default(0) @map("pull_count")
  @@unique([userId, day])
  @@index([day])
  @@map("usage_logs")
}

model RefreshToken {
  id        String    @id @default(uuid())
  userId    String    @map("user_id")
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  tokenHash String    @map("token_hash")
  expiresAt DateTime  @map("expires_at")
  revokedAt DateTime? @map("revoked_at")
  @@index([userId])
  @@index([tokenHash])
  @@map("refresh_tokens")
}

model WrappedDek {
  id            String   @id @default(uuid())
  userId        String   @unique @map("user_id")
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  kdfName       String   @map("kdf_name")
  kdfParams     Json     @map("kdf_params_json")
  saltB64       String   @map("salt_b64")
  wrappedDekB64 String   @map("wrapped_dek_b64")
  updatedAt     DateTime @updatedAt @map("updated_at")
  @@map("wrapped_dek")
}

// Record: sync genérico (oraciones, diario, etc.). Conflictos por version, no por timestamp.
// type = metadato no sensible (p. ej. "prayer_request", "journal_entry"); contenido en encryptedPayloadB64.
model Record {
  id                  String    @id @default(uuid()) @map("record_id")
  userId              String    @map("user_id")
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  type                String    // metadato: tipo de registro; no cifrado
  version             Int
  encryptedPayloadB64 String    @db.Text @map("encrypted_payload_b64") // hasta 512KB por registro (límite en API)
  clientUpdatedAt     DateTime  @map("client_updated_at")
  serverUpdatedAt     DateTime  @updatedAt @map("server_updated_at")
  deleted             Boolean   @default(false)
  status              String    @default("PENDING") // PENDING | IN_PROCESS | ANSWERED
  reminders           Reminder[]
  answers             Answer[]
  @@index([userId])
  @@index([userId, clientUpdatedAt]) // Pull ordenado por clientUpdatedAt
  @@index([userId, status])
  @@map("records")
}

// Recordatorios por pedido de oración: múltiples horarios por record.
model Reminder {
  id         String   @id @default(uuid())
  recordId   String   @map("record_id")
  record     Record   @relation(fields: [recordId], references: [id], onDelete: Cascade)
  time       String   // "HH:mm" ej. "09:00", "21:30"
  daysOfWeek Json     @map("days_of_week") // [0..6] 0=domingo
  isEnabled  Boolean  @default(true) @map("is_enabled")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")
  @@index([recordId])
  @@map("reminders")
}

// Testimonios: cuándo y cómo respondió Dios a un pedido (record con status ANSWERED).
model Answer {
  id         String   @id @default(uuid())
  recordId   String   @map("record_id")
  record     Record   @relation(fields: [recordId], references: [id], onDelete: Cascade)
  answeredAt DateTime @default(now()) @map("answered_at")
  testimony  String?  @db.Text // notas/testimonio sanitizado
  @@index([recordId])
  @@map("answers")
}
